<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="小小卖油翁">
<meta property="og:url" content="https://wolfchenxing.github.io/index.html">
<meta property="og:site_name" content="小小卖油翁">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小小卖油翁">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wolfchenxing.github.io/">





  <title>小小卖油翁</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小小卖油翁</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/06/03/Redis/Redis哨兵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/03/Redis/Redis哨兵/" itemprop="url">Redis哨兵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-03T22:15:07+08:00">
                2020-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h1><p>在主从复制的架构中一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</p>
<p><strong>故障转移过程：</strong></p>
<ol>
<li>主节点发生故障后，客户端（client）连接主节点失败，所有的从节点与主节点连接失败造成复制中断。</li>
<li>如果主节点无法正常启动，需要选出一个从节点，对其执行slaveof no one命令使其成为新的主节点。</li>
<li>原来的从节点成为新的主节点后，更新应用方的主节点信息，重新启动应用方。</li>
<li>客户端命令另一个从节点去复制新的主节点（new-master），slaveof host port</li>
<li>待原来的主节点恢复后，让它去复制新的主节点。</li>
</ol>
<h1 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h1><p>当主节点出现故障时，Redis Sentinel能自动完成故障发现和转移，并通知应用方，从而实现真正的高可用。</p>
<p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。</p>
<p><img src="/images/Redis/Sentinel架构.jpg" alt="Sentinel架构"></p>
<h2 id="Sentinel故障转移过程"><a href="#Sentinel故障转移过程" class="headerlink" title="Sentinel故障转移过程"></a>Sentinel故障转移过程</h2><ol>
<li>每个Sentinel节点通过定期监控发现主节点出现了故障。</li>
<li>多个Sentinel节点对主节点的故障达成一致，选举出一个节点作为领导者负责故障转移</li>
<li>Sentinel领导者节点执行了故障转移</li>
</ol>
<h2 id="Sentinel功能"><a href="#Sentinel功能" class="headerlink" title="Sentinel功能"></a>Sentinel功能</h2><ul>
<li>监控：Sentinel节点会定期检测Redis数据节点、其余Sentinel节点是否可达。</li>
<li>通知：Sentinel节点会将故障转移的结果通知给应用方。</li>
<li>故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li>
<li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li>
</ul>
<h2 id="Sentinel架构的好处"><a href="#Sentinel架构的好处" class="headerlink" title="Sentinel架构的好处"></a>Sentinel架构的好处</h2><ul>
<li>对于节点的故障判断是由多个Sentinel节点共同完成，这样可以有效地防止误判。</li>
<li>Sentinel节点集合是由若干个Sentinel节点组成的，这样即使个别Sentinel节点不可用，整个Sentinel节点集合依然是健壮的。</li>
</ul>
<h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h2 id="配置主节点和从节点"><a href="#配置主节点和从节点" class="headerlink" title="配置主节点和从节点"></a>配置主节点和从节点</h2><p>（1）主节点redis-6379.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#redis以守护进程方式运行</span><br><span class="line">daemonize yes</span><br><span class="line">#日志文件</span><br><span class="line">logfile 6379.log      </span><br><span class="line">#rdb文件</span><br><span class="line">dbfilename dump-6379.rdb</span><br></pre></td></tr></table></figure>
<p>（2）从节点redis-6380.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#redis以守护进程方式运行</span><br><span class="line">daemonize yes</span><br><span class="line">#日志文件</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">#rdb文件</span><br><span class="line">dbfilename &quot;dump-6380.rdb&quot;</span><br><span class="line">#设置主节点</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure></p>
<h2 id="启动主节点和从节点"><a href="#启动主节点和从节点" class="headerlink" title="启动主节点和从节点"></a>启动主节点和从节点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sever redis-6379.conf</span><br><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server redis-6381.conf</span><br></pre></td></tr></table></figure>
<h2 id="确认主从关系"><a href="#确认主从关系" class="headerlink" title="确认主从关系"></a>确认主从关系</h2><p><code>info replication</code>或<code>role</code>命令</p>
<h2 id="配置Sentinel节点"><a href="#配置Sentinel节点" class="headerlink" title="配置Sentinel节点"></a>配置Sentinel节点</h2><p>sentinel-26379.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line"></span><br><span class="line">#sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br><span class="line">#监控127.0.0.1:6379这个主节点，别名demo-master，至少2个Sentinel节点认为失败时做故障转移</span><br><span class="line">sentinel monitor demo-master 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">#sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;</span><br><span class="line">#超过指定秒没有收到节点回复，判为故障下线</span><br><span class="line">sentinel down-after-milliseconds demo-master 30000</span><br><span class="line"></span><br><span class="line">#sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</span><br><span class="line">#故障转移时的从节点向主节点发起并发复制请求的数量</span><br><span class="line">sentinel parallel-syncs demo-master 1</span><br><span class="line"></span><br><span class="line">#sentinel failover-timeout &lt;master-name&gt; &lt;times&gt;</span><br><span class="line">#故障转移超时时间</span><br><span class="line">sentinel failover-timeout demo-master 180000</span><br></pre></td></tr></table></figure></p>
<h2 id="启动Sentinel节点"><a href="#启动Sentinel节点" class="headerlink" title="启动Sentinel节点"></a>启动Sentinel节点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">两种方式启动Sentinel节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1.使用redis-sentinel命令：</span></span><br><span class="line">redis-sentinel sentinel-26379.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">2.使用redis-server命令加--sentinel参数：</span></span><br><span class="line">redis-server sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure>
<h2 id="确认Sentinel"><a href="#确认Sentinel" class="headerlink" title="确认Sentinel"></a>确认Sentinel</h2><p><code>info sentinel</code></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>Sentinel节点不应该部署在同一台物理“机器”上。<br>同一台物理机意味着如果这台机器有什么硬件故障，所有的虚拟机都会受到影响，为了实现Sentinel节点集合真正的高可用。</li>
<li>部署至少三个且奇数个的Sentinel节点。<br>增加Sentinel节点的个数提高对于故障判定的准确性，因为故障转移时领导者选举采用过半原则，奇数个节点可以最低限度满足该条件。</li>
<li>为每个业务场景部署一套Sentinel。</li>
</ul>
<h1 id="Sentinel实现原理"><a href="#Sentinel实现原理" class="headerlink" title="Sentinel实现原理"></a>Sentinel实现原理</h1><h2 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h2><ol>
<li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取Redis数据节点的信息。</li>
</ol>
<p><img src="/images/Redis/Sentinel定时监控任务1.jpg" alt="Sentinel定时监控任务1"></p>
<p><strong>作用：</strong></p>
<ul>
<li>通过向主节点执行info命令，获取从节点的信息，这也是为什么Sentinel节点不需要显式配置监控从节点。</li>
<li>当有新的从节点加入时都可以立刻感知出来。</li>
<li>节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。</li>
</ul>
<ol start="2">
<li>每隔2秒，每个Sentinel节点会向Redis数据节点的<code>__sentinel__：hello</code>频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。</li>
</ol>
<p><img src="/images/Redis/Sentinel定时监控任务2.jpg" alt="Sentinel定时监控任务2"></p>
<p><strong>消息格式：</strong></p>
<p>&lt;Sentinel节点IP&gt; &lt;Sentinel节点端口&gt; &lt;Sentinel节点runId&gt; &lt;Sentinel节点配置纪元&gt;<br>&lt;主节点名字&gt; &lt;主节点Ip&gt; &lt;主节点端口&gt; &lt;主节点配置纪元&gt;</p>
<p><strong>作用：</strong></p>
<ul>
<li>发现新的Sentinel节点：通过订阅主节点的<code>__sentinel__：hello</code>了解其他的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保存起来，并与该Sentinel节点创建连接。</li>
<li>Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</li>
</ul>
<ol start="3">
<li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</li>
</ol>
<p><img src="/images/Redis/Sentinel定时监控任务3.jpg" alt="Sentinel定时监控任务3"></p>
<h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><p>当一个Redis数据节点可能下线时，Sentinel节点需要经过主观下线检查和客观下线检查，如果检查结果都表明Redis数据节点已经下线时，则进入故障转移阶段。</p>
<ol>
<li>主观下线</li>
</ol>
<p>每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定。<br>但这不能的断言节点已经下线，需要结合其他Sentinel节点判断结果进行综合评估。</p>
<p><img src="/images/Redis/Sentinel主观下线.jpg" alt="Sentinel主观下线"></p>
<ol start="2">
<li>客观下线</li>
</ol>
<p>当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过<code>sentinel ismaster-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</quorum></p>
<p>sentinel is-master-down-by-addr <ip> <port> &lt;current_epoch&gt; <runid><br>例如：sentinel is-master-down-by-addr 127.0.0.1 6379 0 *</runid></port></ip></p>
<ul>
<li>ip：主节点IP。<br>-port：主节点端口。</li>
<li>current_epoch：当前配置纪元。</li>
<li>runid：此参数有两种类型，当runid等于“*”时，作用是Sentinel节点直接交换对主节点下线的判定。在领导者Sentinel节点选举时，runid等于当前Sentinel节点的runid，作用是当前Sentinel节点希望目标Sentinel节点同意自己成为领导者的请求。</li>
</ul>
<p>返回结果包含三个参数：</p>
<ul>
<li>down_state：目标Sentinel节点对于主节点的下线判断，1是下线，0是在线。</li>
<li>leader_runid：当leader_runid等于“*”时，代表返回结果是用来做主节点是否不可达，当leader_runid等于具体的runid，代表目标节点同意runid成为领导者。</li>
<li>leader_epoch：领导者纪元。</li>
</ul>
<p><img src="/images/Redis/Sentinel客观下线.jpg" alt="Sentinel客观下线"></p>
<h2 id="领导者Sentinel节点选举"><a href="#领导者Sentinel节点选举" class="headerlink" title="领导者Sentinel节点选举"></a>领导者Sentinel节点选举</h2><p>Sentinel节点对于主节点已经做了主观下线和客观下线后，需要从众多的Sentinel节点中选出一个节点，进行故障转移的工作，所以Sentinel节点之间会在故障转移前线做一个领导者选举的工作。</p>
<p>Redis使用了Raft算法实现领导者选举，大体思路：<br>1) 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点客观下线检查时候，会向其他Sentinel节点发送<code>sentinel is-master-down-by-addr</code>命令，要求将自己设置为领导者。<br>2) 每个节点在每个选举轮次中只有一次投票权，收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的<code>sentinelis-master-down-by-addr</code>命令，将同意该请求，否则拒绝。<br>3) 如果该Sentinel节点发现自己的票数已经大于等于max（quorum，num（sentinels）/2+1），那么它将成为领导者。<br>4) 如果此过程没有选举出领导者，将进入下一次选举，current_epoch加1。</p>
<p>例：</p>
<ol>
<li>s1(哨兵节点)节点首先完成客观下线的检查，然后向s2和s3发送成为领导者的请求，则s1接受的同意为s2、s3</li>
<li>s2节点完成客观下线的检查，然后向s1和s3发送成为领导者的请求，则s2接受的同意为s1</li>
<li>s3节点完成客观下线的检查，然后向s1和s2发送成为领导者的请求，则s3未接受到同意</li>
</ol>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><ol>
<li>在从节点列表中选出一个作为新的主节点<br>[1] 过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。（断线时间越长主从数据不一致问题越严重）<br>[2] 选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。<br>[3] 选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。<br>[4] 选择runid最小的从节点。<br><strong>挑选从节点的重要原则：在从节点列表中挑选与主节点数据最一致的节点。</strong><br><img src="/images/Redis/故障转移选举主节点.jpg" alt="故障转移选举主节点"></li>
<li>Sentinel领导者节点会对第一步选出来的从节点执行<code>slaveof no one</code>命令让其成为主节点。</li>
<li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和parallel-syncs参数有关。<code>slaveof ip port</code></li>
<li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li>
</ol>
<h1 id="Sentinel命令"><a href="#Sentinel命令" class="headerlink" title="Sentinel命令"></a>Sentinel命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.展示所有被监控的主节点状态以及相关的统计信息</span></span><br><span class="line">sentinel masters</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.展示指定&lt;master name&gt;的主节点状态以及相关的统计信息</span></span><br><span class="line">sentinel master&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.展示指定&lt;master name&gt;的从节点状态以及相关的统计信息</span></span><br><span class="line">sentinel slaves&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.展示指定&lt;master name&gt;的Sentinel节点集合（不包含当前Sentinel节点）</span></span><br><span class="line">sentinel sentinels&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5.返回指定&lt;master name&gt;主节点的IP地址和端口</span></span><br><span class="line">sentinel get-master-addr-by-name&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6.对指定&lt;master name&gt;主节点进行强制故障转移</span></span><br><span class="line">sentinel failover&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">7.检测当前可达的Sentinel节点总数是否达到&lt;quorum&gt;的个数</span></span><br><span class="line">sentinel ckquorum&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">8.取消当前Sentinel节点对于指定&lt;master name&gt;主节点的监控</span></span><br><span class="line">sentinel remove&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">9.通过命令的形式来完成Sentinel节点对主节点的监控</span></span><br><span class="line">sentinel monitor&lt;master name&gt;&lt;ip&gt;&lt;port&gt;&lt;quorum&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">10.动态修改Sentinel节点配置选项</span></span><br><span class="line">sentinel set&lt;master name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">11.Sentinel节点之间用来交换对主节点是否下线的判断，根据参数的不同，还可以作为Sentinel领导者选举的通信方式</span></span><br><span class="line">sentinel is-master-down-by-addr</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/05/20/Redis/Redis客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/Redis/Redis客户端/" itemprop="url">Redis客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T21:24:49+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="连接池JedisPool"><a href="#连接池JedisPool" class="headerlink" title="连接池JedisPool"></a>连接池JedisPool</h2><p><img src="/images/Redis/JedisPool.jpg" alt="JedisPool"></p>
<p>Jedis提供了JedisPool这个类作为对Jedis的连接池，同时使用了Apache的通用对象池工具common-pool作为资源的管理工具。</p>
<h2 id="Jedis直连与连接池对比"><a href="#Jedis直连与连接池对比" class="headerlink" title="Jedis直连与连接池对比"></a>Jedis直连与连接池对比</h2><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>直连</td>
<td>简单方便，适用于少量长期连接的场景</td>
<td style="text-align:left">1）存在每次新建/关闭TCP连接开销<br>2）资源无法控制，极端情况会出现连接泄漏<br>3）Jedis对象线程不安全</td>
</tr>
<tr>
<td>连接池</td>
<td>1）无需每次连接都生成Jedis对象，降低开销<br>2）使用连接池的形式保护和控制资源的使用</td>
<td style="text-align:left">相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td>
</tr>
</tbody>
</table>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>（1）场景一：从连接池中取出Jedis，操作完成后未及时还回连接池</strong></p>
<p>连接池中的资源时有限的，默认连接数只有8个，如果处理完成后不及时归还，并且有大量的请求时，连接资源会很快被消耗完。当超过maxTotal值后调用者所在线程将会阻塞直到有连接还回连接池。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>良好的编码习惯，用完即调用Jedis.close()归还连接。</li>
<li>请求量过大导致调用者所在线程阻塞，可以通过设置blockWhenExhausted=true并且设置maxWaitMillis指定最大等待时间，超过该值后将解除阻塞。</li>
</ul>
<p><strong>（2）场景二：连接空闲时间过长导致连接被关闭</strong></p>
<p>连接空闲时间大于客户端设置的timeout时间后，Redis服务器会强制关闭客户端的连接，但是连接池无法获知消息删除无效的连接。如果再从连接池中取出连接进行处理时会抛出异常。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>设置testOnBorrow为true，每次从连接池取连接时会做连接有效性的测试（ping），无效连接会被移除，每次取连接时多执行一次ping命令。</li>
<li>通过设置minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis定期清理失效连接。minEvictableIdleTimeMillis=1000、timeBetweenEvictionRunsMillis=2000 表示后台线程每2s会执行一次清理任务，将空闲时间&gt;1s的连接移除。</li>
</ul>
<h2 id="连接池的配置"><a href="#连接池的配置" class="headerlink" title="连接池的配置"></a>连接池的配置</h2><p><img src="/images/Redis/JedisPool配置.jpg" alt="JedisPool配置"></p>
<h1 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h1><p>Redis服务器与客户端连接成功后，都会创建一个client对象保存道歉客户端的信息。可通过输入<code>client list</code>命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; client list</span><br><span class="line">id=3 addr=127.0.0.1:45820 fd=7 name= age=16 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure></p>
<p>输出每行命令都是代表一个客户端信息，每行中都有十几个属性，它们是客户端的执行状态，理解这些属性对于Redis的开发和运维非常有帮助。</p>
<ul>
<li>addr ： 客户端的地址和端口</li>
<li>fd ： 套接字所使用的文件描述符，普通客户端的fd大于-1。伪客户端的fd是-1，目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件还原数据，另一个用于执行Lua脚本中包含的Redis命令</li>
<li>age ： 以秒计算的已连接时长</li>
<li>idle ： 以秒计算的空闲时长</li>
<li>flags ： 客户端 flag</li>
<li>db ： 该客户端正在使用的数据库 ID</li>
<li>sub ： 已订阅频道的数量</li>
<li>psub ： 已订阅模式的数量</li>
<li>multi ： 在事务中被执行的命令数量</li>
<li>qbuf ： 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li>
<li>qbuf-free ： 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li>
<li>obl ： 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li>
<li>oll ： 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li>
<li>omem ： 输出缓冲区和输出列表占用的内存总量，单位byte</li>
<li>events ： 文件描述符事件，r/w分别代表客户端套接字可读和科协</li>
<li>cmd ： 最近一次执行的命令，不含参数</li>
</ul>
<h2 id="输入缓冲区：qbuf、qbuf-free"><a href="#输入缓冲区：qbuf、qbuf-free" class="headerlink" title="输入缓冲区：qbuf、qbuf-free"></a>输入缓冲区：qbuf、qbuf-free</h2><p>Redis为每个客户端分配了输入缓冲区，作用是将客户端发送的命令临时保存，同时会从输入缓冲区读取命令并执行，它为Redis服务器提供了缓冲功能。</p>
<p>Redis无法配置输入缓冲区的大小，输入缓冲区会根据输入内容大小的不同动态调整，但是总体大小不能超过1G。</p>
<p><strong>输入缓存区使用不当产生的问题:</strong></p>
<ul>
<li>客户端的输入缓冲区超过1G，客户端将会被强制关闭</li>
<li>输入缓冲区不受maxmemory控制，如果redis实例的maxmemory设置了1G，已经存储800M数据， 如果此时输入缓冲区使用了500M，将总内存将超过maxmemory，可能会产生数据丢失、键值淘汰、OOM等情况</li>
</ul>
<p><strong>产生的原因：</strong></p>
<ul>
<li>redis处理速度跟不上输入缓冲区的输入速度，例如存在bigkey，慢查询等原因导致命令执行的时间变长。</li>
<li>写入命令量非常大，但此时redis服务器在执行持久化导致阻塞无法处理命令，导致命令大量积压在输入缓存区中。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><code>client list</code>查看qbuf、qbuf-free来定位存在问题的客户端，分析原因加以处理</li>
<li><code>info clients</code>定期监控client_biggest_input_buf，设置预警阀值超过时发送报警邮件或短信 </li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>在服务器将客户端发送deep命令请求保存到输入缓冲区后，服务器对命令请求的内容进行解析得出命令参数以及命令参数的个数分别保存到客户端的argv和argc中。</p>
<p><strong>client对象属性：</strong></p>
<ul>
<li>argv是一个数组，数组中的每项都是一个字符串对象，其中argv[0]是命令，之后的其他项是传给命令的参数。</li>
<li>argc负责记录argv数组的长度。</li>
<li>cmd命令表字典结构，key是命令的名字，值是redisCommand对象。redisCommand中有命令实现方法、命令接收的参数个数、命令的总执行次数和总消耗时长等统计信息。命令表的查找操作不区分输入字母的大小写。</li>
</ul>
<p><img src="/images/Redis/client对象属性.jpg" alt="client对象属性"></p>
<h2 id="输出缓冲区：obl、oll、omem"><a href="#输出缓冲区：obl、oll、omem" class="headerlink" title="输出缓冲区：obl、oll、omem"></a>输出缓冲区：obl、oll、omem</h2><p>Redis为每个客户端分配了输出缓冲区，作用是保存命令执行的结果返回给客户端，为Redis与客户端交互返回结果提供了缓冲功能。</p>
<p>输出缓冲区的容量可以通过参数<code>client-output-buffer-limit</code>来进行设置。输出缓冲区不受maxmemory控制，如果redis使用内存总量+输出缓冲区的容量大于maxmemory时，会产生数据丢失、键值淘汰、OOM等情况。</p>
<p><strong>配置：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure></p>
<ul>
<li><class>：客户端类型，分为三种。a）normal：普通客户端；b）slave：slave客户端，用于复制；c）pubsub：发布订阅客户端。</class></li>
<li><hard limit>：如果客户端使用的输出缓冲区大于<hard limit>，客户端会被立即关闭。</hard></hard></li>
<li><soft limit>和<soft seconds>：如果客户端使用的输出缓冲区超过了<soft limit>并且持续了<soft limit>秒，客户端会被立即关闭。</soft></soft></soft></soft></li>
</ul>
<p><strong>输出缓冲区按客户端的不同分为三种：普通客户端、发布订阅客户端、slave客户端。</strong></p>
<p><img src="/images/Redis/三种客户端输出缓冲区.jpg" alt="三种客户端输出缓冲区"></p>
<p><strong>输出缓冲区有两部分组成：固定缓冲区（16KB）和动态缓冲区</strong></p>
<ul>
<li>固定缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等。</li>
<li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个有很多元素组成的集合或列表。</li>
</ul>
<p>固定缓冲区使用的是字节数组，动态缓冲区使用的是链表。当固定缓冲区存满后会将Redis新的返回结果存放在动态缓冲区的队列中，队列中的每个对象就是每个返回结果。</p>
<p><img src="/images/Redis/client对象结构.jpg" alt="client对象结构"></p>
<p><img src="/images/Redis/输出缓冲区.jpg" alt="输出缓冲区"></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>通过定期执行client list命令，收集obl、oll、omem找到异常的连接记录并分析，最终找到可能出问题的客户端。</li>
<li>info clients定期监控client_longest_output_list代表输出缓冲区列表最大对象数，设置预警阀值超过时发送报警邮件或短信 。</li>
<li>合理配置普通客户端输出缓冲区的大小。</li>
<li>如果master节点写入较大，适当增大slave的输出缓冲区的，slave客户端的输出缓冲区可能会比较大，一旦slave客户端连接因为输出缓冲区溢出被kill，会造成复制重连。</li>
<li>限制容易让输出缓冲区增大的命令，例如，高并发下的monitor命令就是一个危险的命令。</li>
<li>及时监控内存，一旦发现内存抖动频繁，可能就是输出缓冲区过大。</li>
</ul>
<h2 id="客户端的存活状态"><a href="#客户端的存活状态" class="headerlink" title="客户端的存活状态"></a>客户端的存活状态</h2><p>client list中的age和idle分别代表当前客户端已经连接的时间和最近一次的空闲时间。当age等于idle时，说明连接一直处于空闲状态。</p>
<h2 id="客户端的限制maxclients和timeout"><a href="#客户端的限制maxclients和timeout" class="headerlink" title="客户端的限制maxclients和timeout"></a>客户端的限制maxclients和timeout</h2><p>maxclients参数来限制最大客户端连接数，一旦连接数超过maxclients，新的连接将被拒绝。<br>maxclients默认值是10000，可以通过info clients来查询当前Redis的连接数。</p>
<p>某些情况由于业务方使用不当（例如没有主动关闭连接）可能存在大量idle连接，因此Redis提供了timeout（单位为秒）参数来限制连接的最大空闲时间合理使用有限的资源，一旦客户端连接的idle时间超过了timeout，连接将会被关闭。<br>Redis的默认配置给出的timeout=0，客户端不会因超时而关闭。</p>
<h2 id="客户端类型"><a href="#客户端类型" class="headerlink" title="客户端类型"></a>客户端类型</h2><p><img src="/images/Redis/客户端类型.jpg" alt="客户端类型"></p>
<h2 id="客户端监控"><a href="#客户端监控" class="headerlink" title="客户端监控"></a>客户端监控</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info clients</span><br><span class="line"><span class="meta">#</span><span class="bash"> Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_recent_max_input_buffer:2</span><br><span class="line">client_recent_max_output_buffer:0</span><br><span class="line">blocked_clients:0</span><br></pre></td></tr></table></figure>
<ul>
<li>connected_clients：代表当前Redis节点的客户端连接数，需要重点监控，一旦超过maxclients，新的客户端连接将被拒绝。</li>
<li>client_longest_output_list：当前所有输出缓冲区中队列对象个数的最大值。</li>
<li>client_biggest_input_buf：当前所有输入缓冲区中占用的最大容量。</li>
<li>blocked_clients：正在执行阻塞命令（例如blpop、brpop、brpoplpush）的客户端个数。</li>
<li>total_connections_received(info stats)：Redis自启动以来处理的客户端连接数总数。</li>
<li>rejected_connections：Redis自启动以来拒绝的客户端连接数，需要重点监控。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/05/13/高并发分布式项目亿级流量访问解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/13/高并发分布式项目亿级流量访问解决方案/" itemprop="url">高并发分布式项目亿级流量访问解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T00:58:22+08:00">
                2020-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-亿级流量系统如何架构设计应对流量问题"><a href="#1-亿级流量系统如何架构设计应对流量问题" class="headerlink" title="1 亿级流量系统如何架构设计应对流量问题"></a>1 亿级流量系统如何架构设计应对流量问题</h1><p>流量漏斗：HTTP请求 -&gt; DNS -&gt; 网关（Nginx/F5） -&gt; 应用服务（无状态-中心化） -&gt; 缓存（Redis） -&gt; 数据库（分库分表）</p>
<h1 id="2-突发流量过高的情况下如何进行系统保护"><a href="#2-突发流量过高的情况下如何进行系统保护" class="headerlink" title="2 突发流量过高的情况下如何进行系统保护"></a>2 突发流量过高的情况下如何进行系统保护</h1><p>503/504服务不可用(Nginx)<br>计划型的设计，主要应对已知风险：</p>
<ul>
<li>动静分离：前后端数据分离，将静态资源（图片/视频/JS/CSS/font）存放到CDN</li>
<li>扩容：需要支持扩容，前提是无状态，即服务节点要支持柔性扩展</li>
<li>缓存：引入缓存层将数据从CPU-I/O转变成内存方式</li>
</ul>
<p>当流量激增，我们所有计划型的设计就无效了。<br>以下是两个应急设计：</p>
<ul>
<li>降级：可以通过一些开关或服务设置的一些阈值进行服务的本地存根调用，降级熔断核心目的是为了不让系统出现服务雪崩。非核心业务的CPU、内存等资源倾斜给主链路业务。</li>
<li>限流：确保系统最后的生存底线</li>
</ul>
<h1 id="3-系统保护的终极方案：限流设计"><a href="#3-系统保护的终极方案：限流设计" class="headerlink" title="3 系统保护的终极方案：限流设计"></a>3 系统保护的终极方案：限流设计</h1><p>提示服务正忙，无情把用户拒之门外<br>购买前先进行验证码验证，就是一种业务限流的方式<br>明确的系统限流设计？</p>
<h1 id="4-分布式限流的维度、算法、解决方案分析"><a href="#4-分布式限流的维度、算法、解决方案分析" class="headerlink" title="4 分布式限流的维度、算法、解决方案分析"></a>4 分布式限流的维度、算法、解决方案分析</h1><h2 id="4-1-分布式限流的维度"><a href="#4-1-分布式限流的维度" class="headerlink" title="4.1 分布式限流的维度"></a>4.1 分布式限流的维度</h2><p>有两个核心的维度</p>
<ul>
<li>时间：也就是我们常说的时间窗口，比如每分钟、每秒</li>
<li>资源：时间窗口下可以使用的资源，比如最大访问量、最高可用连接数</li>
</ul>
<p>常用的几种限流规则：</p>
<ul>
<li>QPS和连接数：可以基于某个IP或某个服务器进行限制</li>
<li>传输速率：比如百度网盘</li>
<li>黑白名单：只有开放了白名单的IP和用户才能进行数据API数据的调用，对无效且不友好的访问IP进行黑名单限制</li>
</ul>
<h2 id="4-2-分布式限流的环境"><a href="#4-2-分布式限流的环境" class="headerlink" title="4.2 分布式限流的环境"></a>4.2 分布式限流的环境</h2><p>分布式一定有很多服务节点，有这么多服务节点，来进行限流的控制和校验一定是中心化</p>
<ul>
<li>网关层限流：所有流量的入口，Nginx或者其他的负载均衡HAProxy/Lvs/SLB/F5</li>
<li>中间件限流：比如Redis来做中间件限流控制</li>
</ul>
<h2 id="4-3-分布式限流的算法分析"><a href="#4-3-分布式限流的算法分析" class="headerlink" title="4.3 分布式限流的算法分析"></a>4.3 分布式限流的算法分析</h2><h3 id="4-3-1-令牌桶算法"><a href="#4-3-1-令牌桶算法" class="headerlink" title="4.3.1 令牌桶算法"></a>4.3.1 令牌桶算法</h3><p>如果桶里没有令牌，这时候系统服务无法调用？</p>
<ul>
<li>阻塞式，等</li>
<li>非阻塞，返回异常或者相应信息</li>
</ul>
<h3 id="4-3-2-漏桶算法"><a href="#4-3-2-漏桶算法" class="headerlink" title="4.3.2 漏桶算法"></a>4.3.2 漏桶算法</h3><ul>
<li>恒定速率流出</li>
<li>无法应对突发大流量</li>
</ul>
<h2 id="4-4-限流的实现方案"><a href="#4-4-限流的实现方案" class="headerlink" title="4.4 限流的实现方案"></a>4.4 限流的实现方案</h2><h3 id="4-4-1-客户端限流"><a href="#4-4-1-客户端限流" class="headerlink" title="4.4.1 客户端限流"></a>4.4.1 客户端限流</h3><p>在单机服务上进行流量控制，可以使用Google的Guava</p>
<h3 id="4-4-2-网关层限流"><a href="#4-4-2-网关层限流" class="headerlink" title="4.4.2 网关层限流"></a>4.4.2 网关层限流</h3><p>网关层作为系统流量的入口可以进行所有用户的访问控制<br>Nginx，SpringCloud Gateway/Zuul，F5</p>
<h3 id="4-4-3-中间件限流"><a href="#4-4-3-中间件限流" class="headerlink" title="4.4.3 中间件限流"></a>4.4.3 中间件限流</h3><p>流量已经从网关流入业务层，每个业务都通过Nginx来进行访问，Redis就可以进行中间件限流使用</p>
<h3 id="4-4-4-限流组件"><a href="#4-4-4-限流组件" class="headerlink" title="4.4.4 限流组件"></a>4.4.4 限流组件</h3><p>比如SpringCloud Alibaba sentinel流量防卫兵</p>
<h1 id="5-通过Google-Guava实现客户端方式限流"><a href="#5-通过Google-Guava实现客户端方式限流" class="headerlink" title="5 通过Google Guava实现客户端方式限流"></a>5 通过Google Guava实现客户端方式限流</h1><p>RateLimiter令牌桶，用于单机服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat FORMATTER = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">25</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRateLimiter1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> Thread[THREAD_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            ts[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RateLimiterThread(rateLimiter), <span class="string">"RateLimiterThread-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            ts[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> RateLimiter rateLimiter;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RateLimiterThread</span><span class="params">(RateLimiter rateLimiter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.rateLimiter = rateLimiter;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了令牌，时间 = "</span> + FORMATTER.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-使用Nginx实现网关层限流和数据响应"><a href="#6-使用Nginx实现网关层限流和数据响应" class="headerlink" title="6 使用Nginx实现网关层限流和数据响应"></a>6 使用Nginx实现网关层限流和数据响应</h1><h2 id="6-1-来源IP限流"><a href="#6-1-来源IP限流" class="headerlink" title="6.1 来源IP限流"></a>6.1 来源IP限流</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据IP地址限制速率</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.<span class="variable">$binary_remote_addr</span> 获取IP地址的内存数据占用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.iplimit 自定义的内存区域 10m指内存大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.rate=1r/s 100r/m</span></span><br><span class="line">limit_req_zone $binary_remote_addr zone=iplimit:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	server_name limit.icodingedu.com;</span><br><span class="line">	location /access-limit/ &#123;</span><br><span class="line">		proxy_pass http://locahost:8088/;</span><br><span class="line">		limit_req zone=iplimit burst=2 nodelay;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-服务器级别做限流"><a href="#6-2-服务器级别做限流" class="headerlink" title="6.2 服务器级别做限流"></a>6.2 服务器级别做限流</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=iplimit:10m rate=100r/s;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加服务器限流的规则</span></span><br><span class="line">limit_req_zone $server_name zone=serverlimit:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	server_name limit.icodingedu.com;</span><br><span class="line">	location /access-limit/ &#123;</span><br><span class="line">		proxy_pass http://locahost:8088/;</span><br><span class="line">		limit_req zone=iplimit burst=2 nodelay;</span><br><span class="line">		limit_req zone=serverlimit burst=1 nodelay;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-基于连接数的限制"><a href="#6-3-基于连接数的限制" class="headerlink" title="6.3 基于连接数的限制"></a>6.3 基于连接数的限制</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=iplimit:10m rate=100r/s;</span><br><span class="line">limit_req_zone $server_name zone=serverlimit:10m rate=100r/s;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于IP的连接数限制</span></span><br><span class="line">limit_conn_zone $binary_remote_addr zone=perip:10m;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于服务器的连接数限制</span></span><br><span class="line">limit_conn_zone $server_name zone=perserver:10m;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	server_name limit.icodingedu.com;</span><br><span class="line">	location /access-limit/ &#123;</span><br><span class="line">		proxy_pass http://locahost:8088/;</span><br><span class="line">		limit_req zone=iplimit burst=2 nodelay;</span><br><span class="line">		limit_req zone=serverlimit burst=1 nodelay;</span><br><span class="line"><span class="meta">		#</span><span class="bash"> 应用连接限制并定义连接数</span></span><br><span class="line">		limit_conn perserver 100;</span><br><span class="line">		limit_conn perip 1;</span><br><span class="line"><span class="meta">		#</span><span class="bash"> 对限制的请求设置状态码</span></span><br><span class="line">		limit_req_status 429;</span><br><span class="line">		limit_conn_status 429;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 自定义返回信息</span></span><br><span class="line">	error_page 429 /429;</span><br><span class="line">	lcoation /429 &#123;</span><br><span class="line">		default_type application/json;</span><br><span class="line">		add_header Content-Type 'text/html;charset=utf-8';</span><br><span class="line">		return 200 '&#123;"code":"429","msg":"访问高峰，请稍后再试......"&#125;';</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 下载限速</span></span><br><span class="line">	location /download/ &#123;</span><br><span class="line">		limit_rate_after 100m;</span><br><span class="line">		limit_rate 256k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-使用Redis-Lua脚本实现中间件限流"><a href="#7-使用Redis-Lua脚本实现中间件限流" class="headerlink" title="7 使用Redis+Lua脚本实现中间件限流"></a>7 使用Redis+Lua脚本实现中间件限流</h1><p>Nginx获得的IP才是第一手，在网关层进行IP限制才是最合适的。应用层之间也会进行流量激增或服务的横向调用，服务之间也要引入流量控制，这个地方不能用Nginx。<br>Redis天生可以用来做限流<br>Redis + Lua：解决频繁调用的原子性。方式灵活，可以使用在业务层的任何地方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publiv <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiger</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(redisConnectionFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DefaultRedisScript <span class="title">loadRedisScript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DefaultRedisScript redisScript = <span class="keyword">new</span> DefaultReidsScript();</span><br><span class="line">		<span class="comment">// lua脚本要放在resource下</span></span><br><span class="line">		redisScript.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"ratelimiter.lua"</span>));</span><br><span class="line">		redisScript.setResultType(java.lang.Boolean.class);</span><br><span class="line">		<span class="keyword">return</span> redisScript;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLimiterService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> StringRedisRemplate stringRedisTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisScript&lt;RateLimiter&gt; rateLimitLua;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// key:限流业务的唯一id，limit:一秒内可以访问多少次</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limitAccess</span><span class="params">(String key, Integer limit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> acquire = stringRedisTemplate.execute(</span><br><span class="line">			rateLimitLua, <span class="comment">// lua脚本本身</span></span><br><span class="line">			Lists.newArrayList(key), <span class="comment">// 限流肯定是对某个API</span></span><br><span class="line">			limit.toString()</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">if</span> (!acquire) &#123;</span><br><span class="line">			log.error(<span class="string">"your access is block key is &#123;&#125;"</span>, key);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"YOUR ACCESS IS BLOCKED"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取业务id</span></span><br><span class="line"><span class="keyword">local</span> busKey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 限流大小</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 获取当前流量大小</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, busKey) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 判断是否超流量限制</span></span><br><span class="line"><span class="keyword">if</span> count + <span class="number">1</span> &gt; limit <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">"incrby"</span>, busKey, <span class="number">1</span>)</span><br><span class="line">	redis.call(<span class="string">"expire"</span>, busKey, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="8-SpringCloud-Alibaba限流组件Sentinel实现微服务模块间限流"><a href="#8-SpringCloud-Alibaba限流组件Sentinel实现微服务模块间限流" class="headerlink" title="8 SpringCloud Alibaba限流组件Sentinel实现微服务模块间限流"></a>8 SpringCloud Alibaba限流组件Sentinel实现微服务模块间限流</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spirng-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要一个sentinel的控制台：sentinel-dashboard-1.7.2.jar<br>pom.xml加spring.cloud.sentinel.transport.dashboard:localhost:8080</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/05/10/Redis/Redis实用技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/Redis/Redis实用技巧/" itemprop="url">Redis实用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T16:48:36+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>一条客户端命令的生命周期：</p>
<ol>
<li>命令发送</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息（如发生时间、耗时、命令的详细信息）记录下来。慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此当客户端出现请求超时，需要检查该时间点是否有对应的慢查询。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>每个慢查询日志有4个属性组成，分别是慢查询日志的标识id、发生时间戳、命令耗时、执行命令和参数。</p>
<p><img src="/images/Redis/慢查询日志数据结构.jpg" alt="慢查询日志数据结构"></p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><h3 id="slowlog-log-slower-than"><a href="#slowlog-log-slower-than" class="headerlink" title="slowlog-log-slower-than"></a>slowlog-log-slower-than</h3><p>命令执行时长超过指定阈值时将被记入到慢查询日志中。单位是微妙，默认值10000。0：记录所有命令，&lt;0：对所有命令都不记录。</p>
<p>由于Redis采用单线程相应命令，对于高流量场景，如果命令执行时间在1毫秒以上，那么Redis最多可支撑OPS不到1000。因此对于高OPS场景的Redis建议设置为1毫秒。</p>
<h3 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h3><p>慢查询日志最多存储条数，Redis使用列表存储慢日志。当慢查询日志列表已处于其最大长度，最早插入的一个命令将从列表移除。</p>
<p>由于慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令。为防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化到其他存储中。</p>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul>
<li>slowlog get [n]：获取慢查询日志列表，可指定返回条数</li>
<li>slowlog len：获取慢查询日志列表当前的长度</li>
<li>slowlog reset：清空慢查询日志列表</li>
</ul>
<h1 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h1><table>
<thead>
<tr>
<th style="text-align:left">可执行文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">redis-server</td>
<td>启动redis服务</td>
</tr>
<tr>
<td style="text-align:left">redis-cli</td>
<td>redis命令行工具</td>
</tr>
<tr>
<td style="text-align:left">redis-benchmark</td>
<td>基准测试工具</td>
</tr>
<tr>
<td style="text-align:left">redis-check-aof</td>
<td>AOF持久化文件检测工具和修复</td>
</tr>
<tr>
<td style="text-align:left">redis-check-dump</td>
<td>RDB持久化文件检测工具和修复</td>
</tr>
<tr>
<td style="text-align:left">redis-sentinel</td>
<td>启动redis-sentinel</td>
</tr>
</tbody>
</table>
<h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h2><ul>
<li>-r（repeat）选项代表将命令执行多次</li>
<li>-i（interval）选项代表每隔几秒执行一次命令，但是-i选项必须和-r选项一起使用<br>redis-cli -r 100 -i 1 info | grep used_memory_human</li>
<li>-c（cluster）选项是连接Redis Cluster节点时需要使用的，-c选项可以防止moved和ask异常</li>
<li>如果Redis配置了密码，可以用-a（auth）选项，有了这个选项就不需要手动输入auth命令。</li>
<li>redis-cli.exe –scan –pattern a*，扫描指定pattern格式的key</li>
<li>–slave选项是把当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作</li>
<li>–rdb选项会请求Redis实例生成并发送RDB持久化文件，保存在本地。</li>
<li>–pipe选项用于将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行</li>
<li>–bigkeys选项使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈。</li>
<li>–eval选项用于执行指定Lua脚本</li>
<li>–latency可以测试客户端到目标Redis的网络延迟</li>
<li>–latency的执行结果只有一条，如果想以分时段的形式了解延迟信息，可以使用–latency-history</li>
<li>–latency-dist该选项会使用统计图表的形式从控制台输出延迟统计信息。</li>
<li>–stat选项可以实时获取Redis的重要统计信息，虽然info命令中的统计信息更全，但是能实时看到一些增量的数据（例如requests）对于Redis的运维还是有一定帮助的</li>
<li>–no-raw选项是要求命令的返回结果必须是原始的格式，–raw恰恰相反，返回格式化后的结果</li>
</ul>
<h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>redis-server除了启动Redis外，还有一个–test-memory选项。redis-server –test-memory可以用检测当前操作系统能否稳定地分配指定容量的内存给Redis，通过这种检测可以有效避免因为内存问题造成Redis崩溃，该功能更偏向于调试和测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --test-memory 256</span><br></pre></td></tr></table></figure></p>
<h2 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h2><ul>
<li>-c（clients）选项代表客户端的并发数量（默认是50）。</li>
<li>-n（num）选项代表客户端请求总量（默认是100000）。</li>
<li>-q选项仅仅显示redis-benchmark的requests per second信息。</li>
<li>用-r（random）选项，可以向Redis插入随机的键。-r选项会在key、counter键上加一个12位的后缀，-r10000代表只对后四位做随机处理（-r不是随机数的个数）。</li>
<li>-t选项可以对指定命令进行基准测试。</li>
<li>–csv选项会将结果按照csv格式输出，便于后续处理，如导出到Excel等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 20000 -q</span><br><span class="line">redis-benchmark -c 100 -n 20000 -r 10000</span><br><span class="line">redis-benchmark -t get,set -q</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><p>RTT(Round-Trip Time): 往返时间。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时间。RTT在不同网络环境下会有不同，例如同机房和同机器会比较快，跨机房跨地区会比较慢。</p>
<p>Pipeline（流水线）机制能改善上面这类问题，它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</p>
<p><img src="/images/Redis/Pipeline命令模型.jpg" alt="Pipeline命令模型"></p>
<p><strong>原生批量命令（mget/mset/hmget/hmset） VS Pipeline：</strong></p>
<ul>
<li>原生批量命令是原子的，Pipeline是非原子的。</li>
<li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li>
<li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</li>
</ul>
<p><strong>使用须知:</strong><br>Pipeline虽然好用，但是每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束。它们之间的命令是原子顺序执行的。</p>
<h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ol>
<li><p><strong>事务开始</strong><br>MULTI 命令标志着事务的开始，通过将在客户端状态的flags属性中打开CLIENT_MULTI标识来完成从非事务状态切换至事务状态。</p>
</li>
<li><p><strong>命令入队</strong><br>客户端发送exec、discard、watch、multi四个命令时，服务器立即执行。<br>客户端发送的除此4个命令之外的其他命令时，服务器将命令放入事务队列（FIFO），然后向客户端返回queued。</p>
</li>
<li><p><strong>事务执行</strong><br>处于事务状态的客户端向服务器发送exec命令时，这个命令将被服务器立即执行。服务器首先会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回客户端。</p>
</li>
</ol>
<p><img src="/images/Redis/Redis事务.jpg" alt="Redis事务"></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p><strong>入队错误</strong><br>如果一个事务在入队命令的过程中出现了命令不存在或格式不正确等情况，那么Redis将拒绝执行这个事务，直接退出事务。</p>
</li>
<li><p><strong>执行错误</strong><br>执行命令过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令执行时被触发。<br>执行命令过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的命令，并且已执行的命令不会被出错的命令影响。</p>
</li>
</ul>
<h2 id="Watch命令"><a href="#Watch命令" class="headerlink" title="Watch命令"></a>Watch命令</h2><p>watch命令是一个乐观锁，它可以在exec命令执行之前，监视任意数量的数据库键，并在exec命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p>
<p>每个Redis数据库都有一个watched_keys字典保存被监视的键，字典的key为被监视的键，字典的值是一个链表，记录了所有监视相应数据库键的客户端。</p>
<p><img src="/images/Redis/Watch数据结构.jpg" alt="Watch数据结构"></p>
<p><img src="/images/Redis/Watch流程图.jpg" alt="Watch流程图"></p>
<ol>
<li>watched_keys字典监视的键被修改后，服务器会将对应客户端的标识位置为CLIENT_DIRTY_CAS。</li>
<li>服务端收到exec执行命令，如果当前客户端的标识位是CLIENT_DIRTY_CAS，则拒绝执行，否则提交事务</li>
</ol>
<blockquote>
<p>Redis不支持事务中的回滚，是因为Redis作者认为这种复杂的功能和Redis最求的见到高效的设计主旨不符，并且Redis事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少在实际的生产环境中出现，所以没有必要为Redis开发事务回滚功能。</p>
</blockquote>
<h1 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h1><p>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。Redis提供setbit、getbit、bitcount、bitop、bitpos五个个命令处理二进制数组位，数组的下标在Bitmaps中叫做偏移量。</p>
<p><img src="/images/Redis/Bitmaps.jpg" alt="Bitmaps"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>（1）getbit key <offset></offset></p>
<ol>
<li>计算byte = offset / 8,该值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li>
<li>计算bit = (offset mod 8)+1,bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li>
<li>根据byte与bit返回位数组中指定的二进制位的值。</li>
</ol>
<p>（2）setbit key <offset> <value></value></offset></p>
<ol>
<li>计算所需位数组长度，len=(offset / 8)+1，len记录了保存offset指定的二进制位至少需要多少字节</li>
<li>检查key保存的位数组长度是否小于len，小于则扩展字符串长度位len字节，并将扩展的二进制位的值设置位0</li>
<li>计算byte = offset / 8,该值记录了offset偏移量指定的二进制位保存在位数组的哪个字节</li>
<li>计算bit = (offset mod 8)+1,bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li>
<li>根据byte与bit设置位数组中指定的二进制位的值。</li>
<li>向客户端返回原值</li>
</ol>
<p>（3）bitcount key<br>统计字符串二进制码中，有多少个1<br>bitcount key [start][end]</p>
<p>（4）bitop<br>bitop op destkey key [key….]</p>
<p>bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中。</p>
<p>（5）bitpos<br>bitpos key targetBit [start] [end]<br>bitpos有两个选项[start]和[end]，分别代表起始字节和结束字节，返回字符串里面第一个被设置为1或者0的bit位。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Bitmaps适用于进行快速、简单、实时统计，包括独立访客，日活用户的统计，并且Bitmaps极其节省空间。</p>
<p><strong>独立访客和日活用户统计方案：</strong></p>
<ul>
<li>设置值，setbit key offset value，每个独立用户是否访问过网站存放在Bitmaps中，将访问的用户记做1，没有访问的用户默认为0，用偏移量作为用户的id</li>
<li>获取值，getbit key offset，获取bitmaps当前偏移量的值，判断用户是否已访问</li>
<li>获取指定范围值为1的个数，bitcount [start] [end]，对bitmaps中所有偏移量值为1的个数统计已访问用户总量</li>
<li>bitmaps间运算，bitop op destkey key，如通过and操作符统计连续n天访问网站的用户数量</li>
</ul>
<p>假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户，一天存储量对比如下</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个用户id占用空间</th>
<th>需要存储的用户量</th>
<th>消耗内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set集合</td>
<td>64位（Long类型占8字节）</td>
<td>50,000,000</td>
<td>约400M</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100,000,000</td>
<td>约12.5M</td>
</tr>
</tbody>
</table>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog是一种基数算法，实际类型为字符串，通过HyperLogLog可以利用极小的内存空间完成总数的统计。HyperLogLog提供不精确的去重技术方案，标准误差是0.81%。</p>
<p>在有些情况下， 我们只想要知道在线用户的人数， 而不需要知道具体的在线用户名单， 这时bitmap和集合储存的信息就会显得多余了。在需要尽可能地节约内存并且只需要知道在线用户数量的情况下， 可以使用 HyperLogLog 来对在线用户进行统计： HyperLogLog 是一个概率算法， 它可以对元素的基数进行估算， 并且每个 HyperLogLog 只需要耗费 12 KB 内存， 对于用户数量非常多但是内存却非常紧张的系统， 这一方案无疑是最佳之选。</p>
<p>因此在选用HyperLogLog 时需要明确两点：</p>
<ol>
<li>只为了计算独立总数，不需要获取单条数据。</li>
<li>可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。</li>
</ol>
<p><strong>命令</strong></p>
<ol>
<li><p>添加<br>pfadd key element [element … ]，添加成功返1，失败返回0</p>
</li>
<li><p>统计数量<br>pfcount key [key …]，返回数量</p>
</li>
<li><p>合并<br>pfmerge destkey sourcekey [sourcekey …]</p>
</li>
</ol>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis提供了基于“发布/订阅”模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消息，订阅该频道的每个客户端都可以收到该消息。实现系统之间的解耦。若无消费者订阅，则消息丢失。</p>
<h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><ul>
<li>发布消息<br>publish channel message</li>
<li>订阅消息<br>subscribe channel [channel …]<br>客户端在执行订阅命令之后进入了订阅状态，只能接收subscribe、psubscribe、unsubscribe、punsubscribe的四个命令。<br>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化。</li>
<li>取消订阅<br>unsubscribe [channel [channel …]]</li>
<li>按照模式订阅和取消订阅<br>psubscribe pattern [pattern…]<br>punsubscribe [pattern [pattern …]]</li>
<li>查询订阅<br>查看活跃的频道，pubsub channels [pattern]<br>查看频道订阅数，pubsub numsub [channel …]<br>查看模式订阅数，pubsub numpat</li>
</ul>
<h2 id="订阅实现"><a href="#订阅实现" class="headerlink" title="订阅实现"></a>订阅实现</h2><p>Redis将所有的订阅关系都保存在服务器的名为pubsub_channels的字典表内，字典表的键为频道名，值为链表，表中保存客户端信息。</p>
<p><img src="/images/Redis/普通订阅实现.jpg" alt="普通订阅实现"></p>
<p>模式订阅与与普通订阅原理一致，字典表为pubsub_patterns</p>
<p><img src="/images/Redis/模式订阅实现.jpg" alt="模式订阅实现"></p>
<ul>
<li>频道没有订阅者，则先在字典中为新的频道创建一个键，并将这个键的值设置为空链表，然后在将客户端添加到链表中，成为链表的第一个元素。</li>
<li>频道已经有订阅者，那么它在pubsub_channels字典中必然有相应的订阅者链表，只要将客户端加到订阅者链表的末尾。</li>
</ul>
<h2 id="退订实现"><a href="#退订实现" class="headerlink" title="退订实现"></a>退订实现</h2><p>client-10086退订 “news.sport”,”news.movie”</p>
<p><img src="/images/Redis/退订实现.jpg" alt="退订实现"></p>
<ul>
<li>程序会根据被退订频道的名字， 在 pubsub_channels 字典中找到频道对应的订阅者链表， 然后从订阅者链表中删除退订客户端的信息。</li>
<li>如果删除退订客户端之后， 频道的订阅者链表变成了空链表， 那么说明这个频道已经没有任何订阅者了， 程序将从 pubsub_channels字典中删除频道对应的键。</li>
</ul>
<h2 id="发布实现"><a href="#发布实现" class="headerlink" title="发布实现"></a>发布实现</h2><p>在 pubsub_channels字典里找到对应的频道，将消息发送给所有的订阅者。</p>
<h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><p>Redis3.2版本提供了GEO（地理信息定位）功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p>
<p>GEO的实现主要包含以下两项技术：</p>
<ul>
<li>使用geohash存储地理位置的坐标</li>
<li>使用有序集合（zset）存储地理位置的集合</li>
</ul>
<h2 id="geohash计算步骤"><a href="#geohash计算步骤" class="headerlink" title="geohash计算步骤"></a>geohash计算步骤</h2><p>1) 首先将经度范围(-180, 180)平分成两个区间(-180,0)、(0, 180)，如果目标经度位于前一个区间，则编码为0，否则编码为1。经度的编码长度为26位。<br>2) 用同样的方法将纬度范围(-85.05112878,85.05112878)平分成两个区间(-85.05112878,0)、(0, 85.05112878)。如果目标纬度位于前一个区间，则编码为0，否则编码为1。纬度的编码长度为26位。<br>3) 接下来将经度和纬度的编码合并，奇数位是纬度，偶数位是经度，得出52位的二进制经纬度值<br>4) 将二进制经纬度转换成的整形数值保存到zset有序集合中，score为geohash的52整形值，member为命令中的成员。</p>
<h2 id="geohash特点"><a href="#geohash特点" class="headerlink" title="geohash特点"></a>geohash特点</h2><ul>
<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中。</li>
<li>字符串越长表示的位置更精确。Redis使用的geohash编码长度为26位。可以精确到0.59m的精度。</li>
<li>两个字符串越相似，它们之间的距离越近，Redis利用字符串前缀匹配算法实现相关的命令。</li>
<li>geohash编码和经纬度是可以相互转换的。</li>
</ul>
<h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><p>（1）增加地理位置信息<br>geoadd key longitude latitude member [longitude latitude member …]</p>
<ul>
<li>有效的经度是[-180,180]</li>
<li>有效的纬度是[-85.05112878,85.05112878]</li>
</ul>
<p>（2）获取地理位置信息<br>geopos key member [member …]</p>
<p>（3）获取两个地理位置的距离<br>geodist key member1 member2 [unit]</p>
<p>其中unit代表返回结果的单位，包含以下四种：</p>
<ul>
<li>m（meters）代表米。</li>
<li>km（kilometers）代表公里。</li>
<li>mi（miles）代表英里。</li>
<li>ft（feet）代表尺。</li>
</ul>
<p>（4）获取指定位置范围内的地理信息位置集合<br>georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist]<br>[withhash] [COUNT count] [asc|desc] [store key] [storedist key]</p>
<p>georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist]<br>[withhash] [COUNT count] [asc|desc] [store key] [storedist key]</p>
<ul>
<li>withcoord：返回结果中包含经纬度。</li>
<li>withdist：返回结果中包含离中心节点位置的距离。</li>
<li>withhash：返回结果中包含geohash，有关geohash后面介绍。</li>
<li>COUNT count：指定返回结果的数量。</li>
<li>asc|desc：返回结果按照离中心节点的距离做升序或者降序。</li>
<li>store key：将返回结果的地理位置信息保存到指定键。</li>
<li>storedist key：将返回结果离中心节点的距离保存到指定键。</li>
</ul>
<p>（5）获取geohash<br>geohash key member [member …]</p>
<p>从指定member中读取geohash整形值转为52位二进制数据，然后进行base32编码。</p>
<p><img src="/images/Redis/geohash_base32.jpg" alt="geohash_base32"></p>
<p>该命令最终将返回11个字符的Geohash字符串。</p>
<p>（6）删除地理位置信息<br>zrem key member</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/05/08/Redis/Redis主从复制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/Redis/Redis主从复制/" itemprop="url">Redis主从复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-08T21:03:15+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个Redis副本。复制功能是实现<strong>高可用</strong>Redis的基础。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主服务器出现问题时，可由从服务器提供服务，实现快速的故障恢复，实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主服务器提供写服务，从服务器提供读服务，分担服务器负载；尤其在写少读多的场景，通过多个从服务器分担读负载，可大大提高Redis服务器的并发量</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础，因此主从复制是Redis高可用的基础</li>
</ul>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>主从一对一，适用于故障转移。</p>
<h3 id="星形结构"><a href="#星形结构" class="headerlink" title="星形结构"></a>星形结构</h3><p>适用于读多写少的场景，可以把读命令发送到从节点来分担主节点压力。如：keys命令，可以在其中一台从节点上执行，防止慢查询对主节点造成阻塞从而影响线上服务的稳定性。</p>
<p>面对写多读少的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</p>
<h3 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h3><p>从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过这种结构可以有效降低主节点负载和需要传送给从节点的数据量。</p>
<h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><ol>
<li>从节点保存主节点（master）信息。</li>
<li>从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接。<br>如果从节点无法建立连接，定时任务会无限重试直到连接成功或者执行slaveof no one取消复制。</li>
<li>发送ping命令，检测主从之间网络套接字是否可用和主节点当前是否可接受处理命令。返回pong则继续复制流程，否则断开连接。</li>
<li>权限验证。如果主节点设置了requirepass参数，则需要密码验证，从节点必须配置masterauth参数保证与主节点相同的密码才能通过验证；如果验证失败复制将终止，从节点重新断开重连。</li>
<li>连接成功，发送从节点的ip与port给主节点。</li>
<li><strong>数据同步</strong>。从服务向主服务器发送psync命令开始同步，可以分为全量复制和部分复制。</li>
<li><strong>命令传播</strong>，当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li>
</ol>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>psync ? -1命令发起全量复制请求，一般用于初次复制场景，这时master服务器会将自己的rdb文件发送给slave服务器进行数据同步，并记录同步期间的其他写入，再发送给slave服务器，以达到完全同步的目的。</p>
<p><img src="/images/Redis/全量复制流程图.jpg" alt="全量复制流程图"></p>
<p>RDB文件从创建到传输完毕消耗的总时间超过repl-timeout所配置的值（默认60秒），从节点将放弃接受RDB文件并清理已经下载的临时文件，导致全量复制失败，数据量较大的节点容易出现主从数据同步超时，需要响应的调整repl-timeout的值。</p>
<p>Redis支持无盘复制，生成的RDB文件不保存到硬盘而是直接通过网络发送给从节点，通过repl-diskless-sync参数控制，默认关闭。</p>
<p>client buffer是在server端实现的一个读取缓冲区。redis server在接收到客户端的请求后，把响应结果写入到client buffer中，而不是直接发送给客户端。</p>
<p>client-output-buffer-limit slave 256MB 64MB 60，表示主节点输出给从节点的缓存(output-buffer)大小，从库的复制客户端如果60秒内缓冲区消耗持续大于64MB或者直接超过256MB时，主节点将直接关闭复制客户端连接。</p>
<p>如果主节点创建和传输RDB的时间过长，对于高流量写入场景非常容易造成主节点复制客户端缓冲区溢出。</p>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>psync  <runid> <offset>命令发起部分复制请求，用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。</offset></runid></p>
<p><img src="/images/Redis/部分复制流程图.jpg" alt="部分复制流程图"></p>
<ol>
<li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接。</li>
<li>主从连接中断期间主节点依然响应命令并且保存在主节点的复制积压缓冲区中，但因复制连接中断命令无法发送给从节点。</li>
<li>当主从节点网络恢复后，从节点会再次连上主节点。</li>
<li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li>
<li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li>
<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ol>
<p><strong>构成部分复制的三要素</strong>：复制偏移量、复制积压缓冲区、服务器运行ID</p>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>参与复制的主从节点都会维护自身复制偏移量。主节点（master）在处理完写入命令后，会把命令的字节长度做累加记录。从节点（slave）每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。可以通过主节点的master_repl_offset信息，判断主从节点复制相差的数据量，根据这个差值判定当前复制的健康度。</p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是一个固定长度的FIFO，默认1M，当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区。</p>
<blockquote>
<p>正确的估算和设置复制积压缓冲区的大小，可以避免主服务器执行全量复制；<br>复制积压缓冲区大小=second(服务断开重连时间)*write_size_per_second(每秒写入数据量)</p>
</blockquote>
<h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>主节点根据runid判断能否进行部分复制：</p>
<p>如果从服务器保存的runid与主服务器现在的runid相同，说明主从服务器之前同步过，主服务器会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p>
<p>如果从服务器保存的runid与主服务器现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主服务器，只能进行全量复制。</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>在命令传播阶段，除了发送写命令，主从服务器还维持着心跳机制：PING和REPLCONF ACK</p>
<p><img src="/images/Redis/命令传播阶段.jpg" alt="命令传播阶段"></p>
<p>1）主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。<br>2）从节点在主线程中每隔1秒发送replconf ack {offset}命令，给主节点上报自身当前的复制偏移量。</p>
<p>replconf命令主要作用如下：</p>
<ul>
<li>实时监测主从节点网络状态。</li>
<li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据。</li>
<li>实现保证从节点的数量和延迟性功能，通过min-slaves-to-write、min-slaves-max-lag参数配置定义。</li>
</ul>
<h1 id="操作与配置"><a href="#操作与配置" class="headerlink" title="操作与配置"></a>操作与配置</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>slaveof本身是异步命令，执行slaveof命令时，节点只保存主节点信息后返回，后续复制流程<br>在节点内部异步执行。</p>
<p>方式一：在配置文件中加入 slaveof <masterip> <masterport>，随Redis启动生效<br>方式二：直接使用命令 slaveof <masterip> <masterport>生效</masterport></masterip></masterport></masterip></p>
<blockquote>
<p>用info replication命令查看复制相关信息</p>
</blockquote>
<h2 id="关闭复制"><a href="#关闭复制" class="headerlink" title="关闭复制"></a>关闭复制</h2><p>在从节点执行slaveof no one来断开与主节点复制关系。</p>
<p>关闭复制主要流程：<br>1）关闭与主节点复制关系。<br>2）从节点晋升为主节点。</p>
<p>切换主节点操作流程如下：<br>1）关闭与旧主节点复制关系。<br>2）与新主节点建立复制关系。<br>3）删除从节点当前所有数据。<br>4）对新主节点进行复制操作。</p>
<p>切换主节点后从节点会清空之前所有的数据，但是如果是从节点关闭与主节点的复制关系时不会清空当前节点上的数据。</p>
<h2 id="安全性设置"><a href="#安全性设置" class="headerlink" title="安全性设置"></a>安全性设置</h2><p>为了提升安全性，可以为主节点设置requirepass参数进行密码验证，这时所有的客户端访问必须使用auth命令实行校验，配置从节点的masterauth参数与主节点密码保持一致，这样从节点才可以正确地连接到主节点并发起复制流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主节点设置密码</span><br><span class="line">config set requirepass 123456</span><br><span class="line">// 从节点配置主节点密码</span><br><span class="line">config set materauth 123456</span><br></pre></td></tr></table></figure>
<h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p>由于复制模式是单向的，从节点接收写命令的话无法让主节点感知到，这会造成数据不一致，因此从节点使用slave-read-only=yes配置为只读模式。</p>
<h2 id="数据传输延迟"><a href="#数据传输延迟" class="headerlink" title="数据传输延迟"></a>数据传输延迟</h2><p>repl-disable-tcp-nodelay参数用于控制是否关闭TCP_NODELAY，默认关闭。</p>
<ul>
<li><p>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，如同机架或同机房部署。</p>
</li>
<li><p>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。</p>
</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="数据延迟与不一致"><a href="#数据延迟与不一致" class="headerlink" title="数据延迟与不一致"></a>数据延迟与不一致</h2><p>a、优化主从节点之间的网络环境（如在同机房部署）；<br>b、监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；<br>c、Redis复制提供了slave-serve-stale-data参数，默认开启状态。如果开启则从节点依然响应所有命令。对于无法容忍不一致的应用场景可以设置no来关闭命令执行，此时从节点除了info和slaveof命令之外所有的命令只返回“SYNC with master in progress”信息。</p>
<h2 id="数据过期问题"><a href="#数据过期问题" class="headerlink" title="数据过期问题"></a>数据过期问题</h2><p>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，很容易读取到已经过期的数据。Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。可以使用哨兵机制实现自动故障转移。</p>
<h2 id="复制超时"><a href="#复制超时" class="headerlink" title="复制超时"></a>复制超时</h2><p>注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。<br>主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。</p>
<h2 id="输出缓冲区溢出"><a href="#输出缓冲区溢出" class="headerlink" title="输出缓冲区溢出"></a>输出缓冲区溢出</h2><p>通过client-output-buffer-limit调整输出缓冲区的大小避免复制失败</p>
<h2 id="安全重启"><a href="#安全重启" class="headerlink" title="安全重启"></a>安全重启</h2><p>如内存碎片过高需要重启主服务器，应使用debug reload避免runid与offset改变而执行全量复制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/04/27/Redis/Redis持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/27/Redis/Redis持久化/" itemprop="url">Redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T22:21:55+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul>
<li>save：阻塞式，内存较大的实例在执行过程中会造成长时间的阻塞，影响主进程上的正常服务请求</li>
<li>bgsave：fork子进程，RDB持久化的过程在子进程中进行，完成后自动结束进程。阻塞发生在fork阶段，时间较短。</li>
</ul>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>满足RDB持久化条件后会自动执行持久化过程。</p>
<p><strong>触发条件</strong></p>
<ol>
<li><p>使用save相关配置<br> 配置格式：save <seconds> <changes><br> 表示<seconds>秒内数据集存在<changes>次修改时，自动触发bgsave</changes></seconds></changes></seconds></p>
<blockquote>
<p>实现原理：<br>serverCron服务定时器每100ms执行一次检查，满足以下两个条件进行bgsave<br>（1）now() - rdb_last_save_time &lt; m(指定秒数)<br>（2）rdb_changes_since_last_save &gt; n(修改次数))</p>
</blockquote>
</li>
<li><p>主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点</p>
</li>
<li>debug reload命令</li>
<li>执行shutdown命令时，如果没有开启AOF自动执行bgsave</li>
</ol>
<h2 id="RDB持久化步骤"><a href="#RDB持久化步骤" class="headerlink" title="RDB持久化步骤"></a>RDB持久化步骤</h2><ol>
<li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回</li>
<li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。</li>
<li>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</li>
<li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。</li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项。</li>
</ol>
<h2 id="redis-conf中相关配置"><a href="#redis-conf中相关配置" class="headerlink" title="redis.conf中相关配置"></a>redis.conf中相关配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 默认打开RDB持久化，bgsave自动触发的条件</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">// fork子进程内存不足或RDB文件所在的文件夹没有写入权限，Redis是否停止执行写命令</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">// 是否开启RDB文件压缩，默认采用LZF算法对RDB文件进行压缩。压缩针对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行</span><br><span class="line">rdbcompression yes</span><br><span class="line">// RDB文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">// 是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</span><br><span class="line">rdbchecksum yes</span><br><span class="line">// RDB和AOF文件所在目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>
<h2 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h2><p>RDB文件是经过压缩的二进制文件。不同版本的RDB文件格式不同，故无法利用不同版本的RDB文件恢复数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">----------------------------#</span><br><span class="line">52 45 44 49 53              # 魔数&quot;REDIS&quot;</span><br><span class="line">30 30 30 37                 # RDB数据库版本号，3.0服务器数据库为6，3.2服务器数据库为7. &quot;0007&quot; = 7</span><br><span class="line">----------------------------</span><br><span class="line">FA                          # 辅助信息</span><br><span class="line">$string-encoded-key         # 包括Redis服务器版本，系统32或64位,创建时间，可用内存</span><br><span class="line">$string-encoded-value       #                               </span><br><span class="line">----------------------------</span><br><span class="line">FE 00                       # 数据库编号默认16个库. db number = 00</span><br><span class="line">FB                          # 数据库键值对总数量</span><br><span class="line">$length-encoded-int         # 键值对总数</span><br><span class="line">$length-encoded-int         # 过期键值对总数</span><br><span class="line">----------------------------# Key-Value pair starts</span><br><span class="line">FD $unsigned-int            # 过期时间单位秒, 四个字节长的无符号int表示</span><br><span class="line">$value-type                 # 1个字节，表示编码方式</span><br><span class="line">$string-encoded-key         # key值，字符串类型</span><br><span class="line">$encoded-value              # value值,编码方式</span><br><span class="line">----------------------------</span><br><span class="line">FC $unsigned long           # 过期时间单位毫秒, 八个字节长的无符号int表示</span><br><span class="line">$value-type                 # 1个字节，表示编码方式：string,list,set,inset等共14种</span><br><span class="line">$string-encoded-key         # key值，字符串类型</span><br><span class="line">$encoded-value              # value值,编码方式</span><br><span class="line">----------------------------# 无过期时间的键值对      </span><br><span class="line">$value-type                 # 1个字节，表示编码方式</span><br><span class="line">$string-encoded-key         # key值，字符串类型</span><br><span class="line">$encoded-value              # value值,编码方式</span><br><span class="line">----------------------------</span><br><span class="line">FE $length-encoding         # 当前数据库结束，下一个数据库开始（多个数据库场景）.</span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">FF                          ## RDB文件结束</span><br><span class="line">8-byte-checksum             ## 环冗余校验码，Redis采用crc-64-jones算法，初始值为0.</span><br></pre></td></tr></table></figure>
<p><img src="/images/Redis/rdb-file-structure.jpg" alt="RDB二进制文件结构"></p>
<ol>
<li>REDIS：常量，保存着“REDIS”5个字符。 </li>
<li>db_version：RDB文件的版本号，注意不是Redis的版本号。 </li>
<li>SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。 </li>
<li>EOF：常量，标志RDB文件正文内容结束。 </li>
<li>check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。 </li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>RDB是一个非常紧凑（有压缩）的文件，它保存了某个时间点的数据，非常适用于数据的备份，可以方便传送到另一个远端数据中心，适用于灾难恢复</li>
<li>保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部交由子进程来做，父进程不需要再做其他IO操作，可以最大化Redis性能</li>
<li>与AOF相比，在恢复大的数据集时，RDB方式会更快一些</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>Redis意外宕机时，会丢失部分数据</li>
<li>当Redis数据量比较大时，fork的过程是非常耗时的，fork子进程时是会阻塞的，在这期间Redis不能响应客户端的请求</li>
<li>RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，数据的大量丢失很多时候是无法接受</li>
<li>RDB文件需要满足特定格式，兼容性差</li>
</ul>
<h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态，也就是每当Redis执行一个改变数据集的命令，这个命令就会被追加到AOF文件的末尾。</p>
<h2 id="触发方式-1"><a href="#触发方式-1" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h3><p>使用bgrewriteaof命令：Redis主进程fork子进程来执行AOF重写，这个子进程创建新的AOF文件来存储重写结果，防止影响旧文件。<strong>因为fork采用了写时复制机制，子进程不能访问在其被创建出来之后产生的新数据。</strong>Redis使用“<strong>AOF重写缓冲区</strong>”保存这部分新数据，最后父进程将AOF重写缓冲区的数据写入新的AOF文件中然后使用新AOF文件替换老文件。</p>
<h3 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h3><p>redis.conf中相关配置如下：</p>
<ul>
<li>appendonly：是否打开AOF持久化功能，appendonly默认是 no, 改成appendonly yes</li>
<li>appendfilename：AOF文件名称</li>
<li>appendfsync：同步频率</li>
<li>auto-aof-rewrite-min-size：如果文件大小小于此值不会触发AOF，默认64MB</li>
<li>auto-aof-rewrite-percentage：Redis记录最近的一次AOF操作的文件大小，如果当前AOF文件大小增长超过这个百分比则触发一次重写，默认100</li>
</ul>
<h2 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h2><ol>
<li><strong>命令追加（append）</strong>：所有的写入命令会追加到aof_buf（缓冲区）中。</li>
<li><strong>文件写入（write）和文件同步（sync）</strong>：AOF缓冲区根据对应的策略向硬盘做同步操作。</li>
<li><strong>文件重写（rewrite）：</strong>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li>
<li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li>
</ol>
<p><strong>AOF文件采用文本协议格式的好处</strong></p>
<ul>
<li>文本协议具有很好的兼容性。</li>
<li>文本协议具有可读性，方便直接修改和处理。</li>
<li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。</li>
</ul>
<h2 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h2><h3 id="重写必要性"><a href="#重写必要性" class="headerlink" title="重写必要性"></a>重写必要性</h3><p>重写后的AOF文件缩小文件体积有如下原因：<br>1） 进程内已经唾弃的数据不再写入文件<br>2） 旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a 111、set a222等。重写使用      进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。<br>3） 多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p>
<p>AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p>
<h3 id="重写触发机制"><a href="#重写触发机制" class="headerlink" title="重写触发机制"></a>重写触发机制</h3><p>1）、手动触发，直接调用bgrewriteaof命令。<br>2）、自动触发，根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。</p>
<ul>
<li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</li>
<li>auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</li>
</ul>
<p>自动触发的两个条件:</p>
<ul>
<li>aof_current_size&gt;auto-aof-rewrite-minsize</li>
<li>(aof_current_sizeaof_base_size)/aof_base_size&gt;=auto-aof-rewritepercentage</li>
</ul>
<h3 id="重写工作流程"><a href="#重写工作流程" class="headerlink" title="重写工作流程"></a>重写工作流程</h3><p>1） 执行AOF重写请求。如果当前进程正在执行AOF重写则不执行重写操作，如果进程在执行bgsave则等待执行完毕后再执行。</p>
<p>2） 父进程执行fork创建子进程，开销等同于bgsave过程。</p>
<p>3.1）主进程fork操作完成后，继续响应其他命令。所有修改命令依然写入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性。</p>
<p>3.2）由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</p>
<p>4）子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞。</p>
<p>5.1）新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见info persistence下的aof_*相关统计。</p>
<p>5.2）父进程把AOF重写缓冲区的数据写入到新的AOF文件。</p>
<p>5.3）使用新AOF文件替换老文件，完成AOF重写。</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>支持秒级持久化</li>
<li>可用于不同版本的Redis服务器，兼容性强</li>
<li>AOF文件可读性高，易于分析</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>文件大、恢复速度慢、对性能影响大</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wolfchenxing.github.io/2020/04/26/Redis/Redis数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuting">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小小卖油翁">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/26/Redis/Redis数据结构/" itemprop="url">Redis数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-26T23:48:10+08:00">
                2020-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 对象的数据结构，占4bits，共5种类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象的编码类型，占4bits，共10种类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="comment">// 使用LRU算法计算相对server.lruclock的LRU时间，占24bits</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;</span><br><span class="line">    <span class="comment">// 引用计数，占4bytes</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向底层数据实现的指针，64位系统占8bytes</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Redis/RedisObject.jpg" alt="RedisObject结构"></p>
<h2 id="类型与编码"><a href="#类型与编码" class="headerlink" title="类型与编码"></a>类型与编码</h2><p>通过设置encoding属性来设定对象所使用的编码，而不是为特定对象关联一种固定的编码，极大提升了Redis的灵活性和效率。因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一个场景下的效率。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">编码</th>
<th style="text-align:center">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_INT</td>
<td style="text-align:center">整数值类型的字符串对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_EMBSTR</td>
<td style="text-align:center">EMBSTR字符串对象，少量数据</td>
</tr>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_RAW</td>
<td style="text-align:center">动态字符串对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_LIST</td>
<td style="text-align:center">OBJ_ENCODING_QUICKLIST</td>
<td style="text-align:center">快速列表实现的列表对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_HASH</td>
<td style="text-align:center">OBJ_ENCODING_ZIPLIST</td>
<td style="text-align:center">压缩表实现的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_HASH</td>
<td style="text-align:center">OBJ_ENCODING_HT</td>
<td style="text-align:center">字典实现的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_SET</td>
<td style="text-align:center">OBJ_ENCODING_INTSET</td>
<td style="text-align:center">整数集合实现的集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_SET</td>
<td style="text-align:center">OBJ_ENCODING_HT</td>
<td style="text-align:center">字典实现的集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ZSET</td>
<td style="text-align:center">OBJ_ENCODING_ZIPLIST</td>
<td style="text-align:center">压缩表实现的有序集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ZSET</td>
<td style="text-align:center">OBJ_ENCODING_SKIPLIST</td>
<td style="text-align:center">跳跃表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<p><br></p>
<h1 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h1><p>Redis使用对象来表示数据库中的键值，每当在redis的数据库中创建一个键值对时，将会创建两个对象，即键对象和值对象。</p>
<h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc;</span><br><span class="line">    <span class="comment">// 特殊标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="comment">// 初始化sds分配的数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Redis/String.jpg" alt="String三种编码格式"></p>
<p>如果一个字符串保存的是整数值，并且这个值可以用long类型表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里。并将字符串编码encoding设置为int，1-9999之间的数值字符串在内存中可以复用。</p>
<p>embstr 存储形式是这样一种存储形式，它将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc 方法一次分配。而 raw 存储形式不一样，它需要两次 malloc，两个对象头在内存地址上一般是不连续的。</p>
<p>在字符串比较小时，SDS 对象头的大小是capacity+3——SDS结构体的内存大小至少是 3。意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。如果总体超出了 64 字节，Redis 认为它是一个大字符串，不再使用 emdstr 形式存储，而该用 raw 形式。而64-19-结尾的\0，所以empstr只能容纳44字节。</p>
<blockquote>
<p>扩容策略：<br>字符串在长度小于 SDS_MAX_PREALLOC 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 SDS_MAX_PREALLOC 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 SDS_MAX_PREALLOC 大小的冗余空间。SDS_MAX_PREALLOC 容量大小定义在sds.sh文件中，默认为1024*1024，即1M。</p>
</blockquote>
<h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p>quicklist是在Redis 3.2之后出现的一种Redis底层数据结构用于List结构的具体实现。quickList 是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>
<p><img src="/images/Redis/quicklist.jpg" alt="quicklist结构"></p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同，每个节点可以用来存储一个整数或者一个字符串。</p>
<p><img src="/images/Redis/ziplist.jpg" alt="ziplist结构"></p>
<ul>
<li>zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数</li>
<li>zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。</li>
<li>zllen: ziplist的节点（entry）个数</li>
<li>entry: 节点</li>
<li>zlend: 值为0xFF，用于标记ziplist的结尾</li>
</ul>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p><img src="/images/Redis/ziplist-entry.jpg" alt="ziplist-entry结构"></p>
<ul>
<li>prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist</li>
<li>encoding: 当前节点的编码规则</li>
<li>data: 当前节点的值，可以是数字或字符串</li>
</ul>
<blockquote>
<p>连锁更新：<br>如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点，由于previous entry length大小不够用(1-&gt;5B)，后面所有的节点可能都要重新分配内存大小。因为连锁更新在最坏情况下需要对压缩列表执行N 次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p>
</blockquote>
<h3 id="quicklist参数"><a href="#quicklist参数" class="headerlink" title="quicklist参数"></a>quicklist参数</h3><ul>
<li><strong>list-max-ziplist-size</strong>：取正值时表示quicklist节点ziplist包含的数据项，取负值表示按照占用字节来限定quicklist节点ziplist的长度<ul>
<li>-5：每个quicklist节点上的ziplist大小不能超过64kb</li>
<li>-4：每个quicklist节点上的ziplist大小不能超过32kb</li>
<li>-3：每个quicklist节点上的ziplist大小不能超过16kb</li>
<li>-2：每个quicklist节点上的ziplist大小不能超过8kb（默认值）</li>
<li>-1：每个quicklist节点上的ziplist大小不能超过3kb</li>
</ul>
</li>
<li><strong>list-compress-depth</strong>：list设计最容易被访问的是列表两端的数据，中间的访问频率很低。为此可配置对中间节点进行压缩（采用LZF-一种无损压缩算法），进一步节省内存。<ul>
<li>0：是个特殊值，表示都不压缩（默认值）</li>
<li>1：表示quicklist两端各有1个节点不压缩，中间的节点压缩</li>
<li>2：表示quicklist两端各有2个节点不压缩，中间的节点压缩</li>
</ul>
</li>
</ul>
<h2 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h2><h3 id="hashtable编码"><a href="#hashtable编码" class="headerlink" title="hashtable编码"></a>hashtable编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash索引；当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器</span></span><br><span class="line">    <span class="keyword">int</span> iterators;</span><br><span class="line">&#125; dict;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组，数组的每个项是entry链表的头结点（链地址法解决哈希冲突）</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Redis/dict.jpg" alt="字典结构"></p>
<p><img src="/images/Redis/hash-hashtable.jpg" alt="hash-hashtable结构"></p>
<p>Hashtable采用渐进式rehash，负载因子=已使用节点数量/哈希表大小，在两种情况下对哈希表进行扩展</p>
<ul>
<li>当服务器未执行BGSAVE或BGRWRITEAOF，并且负载因子&gt;1</li>
<li>当服务器执行BGSAVE或BGRWRITEAOF，并且负载因子&gt;5</li>
</ul>
<p>当负载因子&lt;0.1对哈希表进行收缩</p>
<h3 id="ziplist编码"><a href="#ziplist编码" class="headerlink" title="ziplist编码"></a>ziplist编码</h3><p>当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有键值元素的长度都小于hash-max-ziplist-value配置（默认64字节）</li>
<li>哈希对象保存的键值对数量小于hash-max-ziplist-entries配置（默认512个）</li>
</ul>
<p><img src="/images/Redis/hash-ziplist.jpg" alt="hash-ziplist结构"></p>
<h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><p>集合对象的编码可以是intset或hashtable</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每个整数的类型 int16/int32/int64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// intset长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 整数数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Redis/set.jpg" alt="set结构"></p>
<p>当集合对象同时满足以下两个条件时，集合对象使用intset编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>哈希对象保存的键值对数量不超过set-max-intset-entries配置（默认512个）</li>
</ul>
<h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><h3 id="ziplist编码-1"><a href="#ziplist编码-1" class="headerlink" title="ziplist编码"></a>ziplist编码</h3><p><img src="/images/Redis/zset-ziplist.jpg" alt="zset-ziplist结构"></p>
<p>当有序集合对象同时满足以下两个条件时，有序集合对象使用ziplist编码：</p>
<ul>
<li>有序集合对象保存的所有成员的长度都小于zset-max-ziplist-value配置（默认64字节）</li>
<li>有序集合对象保存的所有元素数量小于zset-max-ziplist-entries配置（默认128个）</li>
</ul>
<h3 id="skiplist编码"><a href="#skiplist编码" class="headerlink" title="skiplist编码"></a>skiplist编码</h3><p><img src="/images/Redis/zset-skiplist.jpg" alt="zset-skiplist结构"></p>
<p>跳表具有如下性质：</p>
<ul>
<li>由很多层结构组成</li>
<li>每个节点的层数随机生成（Redis5.0版本ZSKIPLIST_MAXLEVEL为64）</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li>
</ul>
<p><img src="/images/Redis/skiplist.jpg" alt="skiplist结构"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Yuting">
            
              <p class="site-author-name" itemprop="name">Yuting</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuting</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">20.7k</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
